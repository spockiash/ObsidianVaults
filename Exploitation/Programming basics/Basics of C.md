# Strings
In C strings are basically an arrays of type `char`. Arrays in C are also referred to as buffers. Here is an example of character array:
```c
#include <stdio.h>
int main()
{
	char str_a[20];
	str_a[0] = 'H';
	str_a[1] = 'e';
	str_a[2] = 'l';
	//...
	str_a[13] = '\n';
	str_a[14] = 0;
	printf(str_a);
}
```
The last character stored is 0, which is called null byte. Null byte is used to tell a function that it has come to a stop. This is what is called a delimiting character. The rest elements of the 20 byte array are random garbage. We can put null byte anywhere and it will stop the string where we put it.

Normally programmers deal with strings instead of character arrays and there. For this there are functions that are used for string manipulation. For example `strcpy` is used to copy source string into destination.
It works by iterating on the source until it encounters null byte. It copies each byte and after it encounters the null byte, it copies it and stops. With this in mind we can rewrite above program to use `strcpy`:
```c
#include <stdio.h>
#include <string.h>

int main()
{
	char str_a[20];
	
	strcpy(str_a, "Hello world\n");
	printf(str_a);
}
```
We can then setup `gdb` to set breakpoints before `strcpy` and after it to examine what is going on. The `strcpy` function is part of external library and therefore the `gdb` can set the breakpoint only when the program is executed:
```sh
bobo@bobo-ws ➜ gdb -q ./main
Reading symbols from ./main...
(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main()
5       {
6           char str_a[20];
7           
8           strcpy(str_a, "Hello world\n");
9           printf(str_a);
10      }
(gdb) break 7
Breakpoint 1 at 0x1160: file main.c, line 8.
(gdb) break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) break 9
Breakpoint 3 at 0x117f: file main.c, line 9.
```
When the program is run, the breakpoint is resolved. At each breakpoint we are going to see the `rip` register and see the instruction it is pointing to. Notice that the memory location when executing `strcpy` is different:
```sh
Reading symbols from ./main...
(gdb) break strcpy
Breakpoint 1 at 0x1030
(gdb) break 6
Breakpoint 2 at 0x1170: file main.c, line 6.
(gdb) break 8
Breakpoint 3 at 0x118d: file main.c, line 8.
(gdb) run
Starting program: /home/bobo/Projects/C/C_To_Assembly/src/main 

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.archlinux.org>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Breakpoint 2, main () at main.c:6
6           int debug = 0;    
(gdb) i r rip
rip            0x555555555170      0x555555555170 <main+23>
(gdb) x/5i
Argument required (starting display address).
(gdb) x/5i $rip
=> 0x555555555170 <main+23>:    mov    DWORD PTR [rbp-0x24],0x0
   0x555555555177 <main+30>:    lea    rax,[rbp-0x20]
   0x55555555517b <main+34>:    lea    rdx,[rip+0xe82]        # 0x555555556004
   0x555555555182 <main+41>:    mov    rsi,rdx
   0x555555555185 <main+44>:    mov    rdi,rax
(gdb) continue
Continuing.

Breakpoint 1, __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:64
64      ENTRY(STRCPY)
(gdb) i r rip
rip            0x7ffff7f0b130      0x7ffff7f0b130 <__strcpy_avx2>
(gdb) x/5i $rip
=> 0x7ffff7f0b130 <__strcpy_avx2>:      endbr64
   0x7ffff7f0b134 <__strcpy_avx2+4>:    vpxor  xmm7,xmm7,xmm7
   0x7ffff7f0b138 <__strcpy_avx2+8>:    mov    eax,esi
   0x7ffff7f0b13a <__strcpy_avx2+10>:   and    eax,0xfff
   0x7ffff7f0b13f <__strcpy_avx2+15>:   cmp    eax,0xfe0
(gdb) continue
Continuing.

Breakpoint 3, main () at main.c:8
8           printf(str_a);
(gdb) i r rip
rip            0x55555555518d      0x55555555518d <main+52>
(gdb) x/5i $rip
=> 0x55555555518d <main+52>:    lea    rax,[rbp-0x20]
   0x555555555191 <main+56>:    mov    rdi,rax
   0x555555555194 <main+59>:    mov    eax,0x0
   0x555555555199 <main+64>:    call   0x555555555050 <printf@plt>
   0x55555555519e <main+69>:    mov    eax,0x0
```
The above code show that when we call function from external source, the debugger has to first load it. When it is loaded we can set breakpoint to that function and examine its location in memory. We can see that the start of `strcpy` lives at `0x7ffff7f0b130` address and the `rip` register points to it when the breakpoint is hit. Then when we hit breakpoint at `printf` we can see that we returned to our program stack frame. The `rip` register therefore can move between different stack frames and jump back and forth between them.

Each time function is called a record is kept on data structure called stack. The stack allows `rip` to return through long chain of calls. The `gdb` has feature called `bt`. It allows to backtrace the stack. The stack backtrace can be seen at each breakpoint:
```sh
Breakpoint 2, main () at main.c:6
6           int debug = 0;    
(gdb) bt
#0  main () at main.c:6
(gdb) continue
Continuing.

Breakpoint 1, __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:64
64      ENTRY(STRCPY)
(gdb) bt
#0  __strcpy_avx2 () at ../sysdeps/x86_64/multiarch/strcpy-avx2.S:64
#1  0x000055555555518d in main () at main.c:7
(gdb) continue
Continuing.

Breakpoint 3, main () at main.c:8
8           printf(str_a);
(gdb) bt
#0  main () at main.c:8
```
The `strcpy` call is on slightly different address now. This is because of Linux kernel exploit protection. 
# Integer types
In C there are multiple sizes of integer values. Common `int` type has 32 bites both in its signed and unsigned form. 32 bit signed integer occupies 32 bits and portion of that is designated to the signage. Unsigned integer has full range of 32 bits.

```
### 1. **Unsigned Integer Range:**

For an unsigned integer with `n` bits:

Minimum Value=0\text{Minimum Value} = 0Minimum Value=0 Maximum Value=2n−1\text{Maximum Value} = 2^n - 1Maximum Value=2n−1

### 2. **Signed Integer Range:**

For a signed integer with `n` bits (assuming two's complement representation, which is the most common):

Minimum Value=−2(n−1)\text{Minimum Value} = -2^{(n-1)}Minimum Value=−2(n−1) Maximum Value=2(n−1)−1\text{Maximum Value} = 2^{(n-1)} - 1Maximum Value=2(n−1)−1
```
The range for unsigned integer is from 0 to 4,294,967,295. Signed integer has values from -2,147,483,648 to -2,147,483,647. For the signed integer one bit is a flag that determines if the value is above or beyond zero.

Positively signed values look the same as unsigned values, but negatively signed values use a method called two's complement. With this method when negative and positive values of the same magnitude are added together, the result is 0. This is done by given an positive value, all the bits are reversed and finally adding 1. As a result of this, negative values can be added with combination of positive values using simple binary adders.

This can be explored with `pcalc` a simple programmers calculator:
```sh
bobo@bobo-ws ➜ pcalc 0y01001001  
       73                      0x49                    0y1001001  
bobo@bobo-ws ➜ pcalc 0y10110110 + 1  
       183                     0xb7                    0y10110111  
bobo@bobo-ws ➜ pcalc 0y01001001 + 0y10110111  
       256                     0x100                   0y100000000
```

The program is not aware that we are using 8-bit data, so when we add the positive value with the two's complement representation of negative number we get 256. In the CPU this will be value of 0, because the binary representation ends in 9 bits. So this will zero out the value in the CPU's perspective.

In c the values can be marked as unsigned simply using keyword `unsigned` before the `int` keyword. Additionally we can use larger or smaller bit size of integer using keywords `long` and `short`. The actual size is architecture dependent.

To see the size of a value, we can use macro `sizeof()` that can determine the size of a given data type:
```c
#include <stdio.h>
int main() {
	printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
	printf("The 'unsigned int' data type is\t\t %d bytes\n", sizeof(unsigned int));
	printf("The 'short int' data type is\t\t %d bytes\n", sizeof(short int));
	printf("The 'long int' data type is\t\t %d bytes\n", sizeof(long int));
	printf("The 'long long int' data type is\t\t %d bytes\n", sizeof(long long int));
	printf("The 'float' data type is\t\t %d bytes\n", sizeof(float));
	printf("The 'char' data type is\t\t %d bytes\n", sizeof(char));
	return 0;
}
```
The above will code demonstrates usage of `sizeof()` macro. The result will be:
```sh
bobo@bobo-ws ➜ ./datatype_sizes 
The 'int' data type is           4 bytes
The 'unsigned int' data type is          4 bytes
The 'short int' data type is             2 bytes
The 'long int' data type is              8 bytes
The 'long long int' data type is                 8 bytes
The 'float' data type is                 4 bytes
The 'char' data type is          1 bytes
```
The `long` and `short` can be used together with `float` type as well.

# Pointers
The register `rip` in the CPU is pointer that points to somewhere in memory for the instruction to be executed. In C there are also pointers and they are used to point to somewhere in memory. The reason for pointers existence is lower demand on performance as opposed to manipulating entire memory segments. For example copy operation can be expensive and using pointers instead will greatly reduce demand on performance.

Pointers in 32-bit `x86` architecture is 4 bytes in size, for 64 bit it is 8 bytes. In C pointers are marked with `*` symbol before the name of the variable. Instead of defining a variable of that type, pointer is defined as something that points to that data type. The following program is an example that uses pointer of 1 byte size:
```c
#include <stdio.h>
#include <string.h>

int main() {
	char str_a[20];
	char *pointer;
	char *pointer2;
	
	strcpy(str_a, "Hello, world!\n");
	pointer = str_a; //Set the first pointer here
	printf(pointer);
	
	pointer2 = pointer + 2; //Set the start of the new pointer with 2 bytes offset from beginning
	printf(pointer2);
	strcpy(pointer2, "y you guys!\n");
	printf(pointer);
	return 0;
}
```
The first pointer is set at a beginning of a character array. When character array is referenced like this, the actual array is pointer itself. This is how we can reference pointers to buffers when using functions like `printf()` or `strcpy()`.

The second pointer is set to the first pointer's address plus two. Then some things are printed. The output will be:
```sh
bobo@bobo-ws ➜ ./pointers                   
Hello, world!
llo, world!
Hey you guys!
```

When we look at the program with debugger and set a breakpoint at line after the `pointer` variable is assigned value with `str_a` we can see that the pointer shows the actual string. This is because pointers in C behave as the variable it points to unless we use address-of operator `&` as show below:
```sh
(gdb) x/xw pointer //display first bytes stored at the memory location 
0x7fffffffd7c0: 0x6c6c6548
(gdb) x/s pointer
0x7fffffffd7c0: "Hello, world!\n"
(gdb) x/xw &pointer
0x7fffffffd7b0: 0xffffd7c0
```

Remember that the string itself is not in the pointer variable, it just contains address to the string. When the address-of operator `&` is used, it returns the memory address of the pointer.

There is also an dereference operator `*`. This operator returns data stored at an address. Since pointer is storing the address of some data, we can use this to retrieve values. Below is code that shows this in action:
```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float value = 5.045;
    float *pointer;

    pointer = &value;
    printf("Pointer value (address of value): %p\n", (void*)pointer);
    //prints address of where the pointer is pointing
    printf("Value of pointer: %f\n", *pointer);
    //prints the value of `5.045`
    return 0;
}
```

## Example of address-of operator
The address-of operator `&` can be used to retrieve the address of an object. Most commonly is it to assign value to a pointer. Here is an example where we initialize integer value and declare a pointer. Then we use the address-of `&` operator to assign address value of our integer variable:
```c
#include <stdio.h>
#include <string.h>
	int main() {
	int int_var = 5;
	int *int_ptr;
	int_ptr = &int_var; //assign address of int_var to pointer int_ptr
	return 0;
}
```
 When we put breakpoint at the end of the program, we can print the `int_var` variable value and its address. We can also print `int_ptr` value and address of the pointer itself:
 ```sh
	 Breakpoint 1, main () at addressof.c:9
	9           return 0;
	(gdb) print int_var
	$1 = 5 //the value stored in int_var
	(gdb) print &int_var
	$2 = (int *) 0x7fffffffd7cc //the address of int_var
	(gdb) print int_ptr
	$3 = (int *) 0x7fffffffd7cc //the address stored in int_ptr
	(gdb) print &int_ptr
	$4 = (int **) 0x7fffffffd7d0 //the address of the pointer itself
	(gdb) 
```
## Example of dereference operator
Dereference is another unary operator `*`. This operator will return data stored at given address. With pointers this means this operator will return data found at address stored in the pointer instead of the address itself. This operator exists in C and `gdb`:
```sh
(gdb) print *int_ptr
$5 = 5
```

Both operators can be shown working in this code:
```c
#include <stdio.h>
#include <string.h>

int main() {
	unsigned int int_var = 5;
	unsigned int *int_ptr;
	int_ptr = &int_var; //put the address of int_var into int_ptr
	
	printf("int_ptr = 0x%08x\n", int_ptr);
	printf("&int_ptr = 0x%08x\n", &int_ptr);
	printf("*int_ptr = 0x%08x\n", *int_ptr);
	
	printf("int_var is located at 0x%08x and contains %d\n", &int_var, int_var);
	printf("int_ptr is located at 0x%08x and points to %d\n", &int_ptr, *int_ptr);
	return 0;
}
```
The output of this program is:
```sh
bobo@bobo-ws ➜ ./addressof2                         
int_ptr = 0x5adac6bc
&int_ptr = 0x5adac6c0
*int_ptr = 0x00000005
int_var is located at 0x5adac6bc and contains 5
int_ptr is located at 0x5adac6c0 and points to 5
```
When the unary operators are used they can be thought as having direction of motion. The address-of operator moves backwards and dereference operator moves forwards in the direction the pointer is pointing:
![[Pasted image 20240909133254.png]]
The address of operator's arrow is aiming towards the pointer, because the result of the operation is address of that variable. The dereference operator's arrow is aiming towards the variable, because the result of that operation is value stored at address the pointer is pointing to.
# Format Strings
Format strings, format options or format specifiers are special escape sequences used for displaying output using `printf()` function. It tells the function where to place a value of an variable. Each format specifier starts with symbol `%` and are placed inside string literals. The syntax is very similar with `gdb` examine syntax.

There are format specifiers that receive their data as values, not pointers to values. For example:
* `%d` - Decimal
* `%u` - Unsigned decimal
* `%x` - Hexadecimal
But there are format specifiers that expect pointers like:
* `%s` - String
* `%n` - Number of writes written so far
The String format specifier expects pointer and starts reading until it reads null-byte. The `%n` specifier reads the number of writes written so far to given address and then writes the actual value. 

Below is an code that shows different uses of a format specifiers:
```c
#include <stdio.h>
#include <string.h>

int main() {
	char string[10];
	int A = -73;
	unsigned int B = 31337;
	strcpy(string, "sample");
	
	//Example of printing with different format strings:
	printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A,A,A);
	printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B,B,B);
	printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
	printf("[string] %s Address %08x\n", string, string);
	
	//Example of unary address operator (dereferencing) and a %x format string
	printf("variable A is at address %08x\n", &A);
	return 0;
}
```
The output is as follows:
```sh
bobo@bobo-ws ➜ ./fmt_strings 
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample Address 67597a8e
variable A is at address 67597a84
```
For each specifier there needs to be corresponding variable supplied. In case of multiple specifiers the variables must be in correct order. The `%d` format specifier accepts negative values while `%u` does accept only positive values.

When we try to print negative value of variable `A` using the format specifier `%u` the number appears to be very high. This is because two's complement method for storing negative values.

The third print line uses width specifier. It is placed before the letter of that specifier for example `%10u`. This will specify minimum field width of the printed value. However this does not specify maximum. If the value is greater it will exceed. This happens when 3 is used, since the output data needs 5 bytes. When 10 is used, 5 bytes of blank data is outputted before the output data. Additionally, if a field width value starts with `0`, the output field will be padded with `0`s.

The `[string]` line shows that when used `%s` format option, given an address the output is the string read until it encounters the null-byte. This format specifier expects the parameter to be passed as reference.

The final line just shows the address where variable `A` lives. The value is displayed as hexadecimal with padded zeroes. The format strings can be used with variety of I/O functions including `scanf()`. This is input function and expects all parameters to be pointers. The arguments must therefore be variable addresses and not the variables themselves. This can be done using pointers or using the address-of operator:
```c
#include <stdio.h>
#include <string.h>
int main() {
	char message[14];
	int count, i;
	strcpy(message, "Hello world!\n");
	printf("Repeat how many times? ");
	scanf("%d", &count);
	for (i=0; i < count; i++) {
		printf("%3d - %s", i, message);
	}
	return 0;
}
```
# Typecasting
Typecasting is way of temporarily changing variables type. When the variable is cast into a different type, the compiler is told to treat the variable as different type. The syntax for typecasting is as follows:
```c
(typecast_new_type) variable; 
```
This can be demonstrated by dealing with floating points and integers:
```c
#include <stdio.h>
#include <string.h>

int main() {
	int a, b;
	float c, d;
	
	a = 13;
	b = 5;
	
	c = a / b;
	d = (float) a / (float) b;
	
	printf("[integers]:\t a = %d\t b = %d\n", a, b);
	printf("[floats]:\t c = %f\t d = %f\n", c, d);
	return 0;
}
```
The result of this program is:
```sh
bobo@bobo-ws ➜ ./typecasting                      
[integers]:      a = 13  b = 5
[floats]:        c = 2.000000    d = 2.600000
```
When we divide integers 13 and 5 the result is 2, which is incorrect even when we store it into floating point variable. However, when we cast the operands as floats we get the correct answer in variable `d`.

Typecasting shines when used with pointers. C compiler expects pointers to have type, one reason for this is to limit programmers error. Integer pointer should point to integers and so on. Another reason for this is pointer arithmetic. Integer pointer is 4 bytes, while character pointer is 1 byte. When we add to pointers, the type of the pointer is important, otherwise we might read random junk. Using pointers and pointer arithmetic can be demonstrated using following code:
```c
#include <stdio.h>
#include <string.h>

int main() {
	char char_array[5] = {'a', 'b', 'c','d','e'};
	int int_array[5] = {1, 2, 3, 4, 5};
	
	char *char_pointer;
	int *int_pointer;
	
	char_pointer = char_array;
	int_pointer = int_array;
	
	for (i = 0; i < 5; i++) {
		printf("[int pointer] points to %p, which contains the integer %d\n", int_pointer, *int_pointer);
		int_pointer = int_pointer + 1;
	}
	for (i = 0; i < 5; i++) {
		printf("[char pointer] points to %p, which contains the integer '%c'\n", char_pointer, *char_pointer);
		char_pointer = char_pointer + 1;
	}
	return 0;
}
```
The`%p` is shorthand for displaying pointer address in proper format instead of `0x%08x` format specifier. The output is:
```sh
bobo@bobo-ws ➜ ./pointer_types                     
[int pointer] points to 0x7ffc86e102e0, which contains the integer 1
[int pointer] points to 0x7ffc86e102e4, which contains the integer 2
[int pointer] points to 0x7ffc86e102e8, which contains the integer 3
[int pointer] points to 0x7ffc86e102ec, which contains the integer 4
[int pointer] points to 0x7ffc86e102f0, which contains the integer 5
[char pointer] points to 0x7ffc86e10303, which contains the integer 'a'
[char pointer] points to 0x7ffc86e10304, which contains the integer 'b'
[char pointer] points to 0x7ffc86e10305, which contains the integer 'c'
[char pointer] points to 0x7ffc86e10306, which contains the integer 'd'
[char pointer] points to 0x7ffc86e10307, which contains the integer 'e'
```
In the code above we define 2 arrays, one for integers and one for characters. Then we declare pointers for each array and assign them. After that we have 2 loops that iterate and display the memory address and value stored there. Notice we use dereference operator `*` to get the value.

In each loop we add 1 to the pointer. This is where the pointer type is important, because each `+ 1` operation behaves differently based on the pointer type. In case of character array the add operation increases the pointer address by one byte. For integer values we increase it by 4 bytes. If we were to switch the pointer assignment like this:
```c
char_pointer = int_array;
int_pointer = char_array;
```
We would get a nonsense output, because the pointer increments would be by wrong byte amount. The compiler should warn us about this or give an error. There are situations like this commonly in C programming. Since the pointer type determines the size of the data it is pointing to, the types should always be correct. 

We can remedy this using pointer casting when we switch the pointers:
```c
#include <stdio.h>
#include <string.h>

int main() {
	char char_array[5] = {'a', 'b', 'c','d','e'};
	int int_array[5] = {1, 2, 3, 4, 5};
	
	char *char_pointer;
	int *int_pointer;
	
	char_pointer = (char *)int_array;
	int_pointer = (int *)char_array;
	
	for (i = 0; i < 5; i++) {
		printf("[int pointer] points to %p, which contains the char %c\n", int_pointer, *int_pointer);
		int_pointer = (int *) ((char *)int_pointer + 1);
	}
	
	for (i = 0; i < 5; i++) {
		printf("[char pointer] points to %p, which contains the integer '%d'\n", char_pointer, *char_pointer);
		char_pointer = (char *) ((int *)char_pointer + 1);
	}
	
	return 0;
}
```
In the code above we assign wrong pointers to wrong arrays, but we use pointer casting. Then in each loop we change the output string to accommodate the stored data type and we cast the pointer when performing pointer arithmetic and after that we cast it back into its original pointer type. This will result in following output:
```sh
bobo@bobo-ws ➜ ./pointer_types3                      
[int pointer] points to 0x7ffd556b3003, which contains the char a
[int pointer] points to 0x7ffd556b3004, which contains the char b
[int pointer] points to 0x7ffd556b3005, which contains the char c
[int pointer] points to 0x7ffd556b3006, which contains the char d
[int pointer] points to 0x7ffd556b3007, which contains the char e
[char pointer] points to 0x7ffd556b2fe0, which contains the integer '1'
[char pointer] points to 0x7ffd556b2fe4, which contains the integer '2'
[char pointer] points to 0x7ffd556b2fe8, which contains the integer '3'
[char pointer] points to 0x7ffd556b2fec, which contains the integer '4'
[char pointer] points to 0x7ffd556b2ff0, which contains the integer '5'
```
## Void pointer
In general it is good to use the pointers with correct types, so we can avoid badly readable code. But sometimes we require to use more generic pointer type. C offers typeless pointer defined by keyword `void`. 

Pointers cannot be dereferenced unless they have a type. In order to see the value behind pointer address, the compiler must know its type. Also void pointers must be typecast before doing any pointer arithmetic. With these limitations, the main purpose of void pointer is to simply hold an memory address.

With this in mind we can rewrite the program above to use single void pointer:
```c
#include <stdio.h>
#include <string.h>

int main() {
	char char_array[5] = {'a', 'b', 'c','d','e'};
	int int_array[5] = {1, 2, 3, 4, 5};
	
	void *void_pointer;
	void_pointer = (void *) char_array;
	
	for (i = 0; i < 5; i++) {
	printf("[int pointer] points to %p, which contains the char %c\n", void_pointer, *((char *)void_pointer));
	void_pointer = (void *) ((char *)void_pointer + 1);
	}
	
	void_pointer = (void *) int_array;
	for (i = 0; i < 5; i++) {
	printf("[char pointer] points to %p, which contains the integer '%d'\n", void_pointer, *((int *)void_pointer));
	void_pointer = (void *) ((int *)void_pointer + 1);
	}
	
	return 0;
}
```
The output is the same as previous example. It will print contents of the arrays using single void pointer. Notice that we need to cast the void pointer to proper type when using pointer arithmetic. Also the pointer must be typecasted when dereferencing it:
```c
*((char *)void_pointer)
```
Since the type is taken care of by typecasting, the void pointer is truly just holding the address. With the data types being defined by typecasting, anything that is big enough to hold four-byte value can work the same way as void pointer. Below is example of the code above that uses `unsigned long` pointer instead:
```c
#include <stdio.h>
#include <string.h>


int main() {
	int i;
	
	char char_array[5] = {'a', 'b', 'c','d','e'};
	int int_array[5] = {1, 2, 3, 4, 5};
	
	unsigned long hacky_nonpointer;
	hacky_nonpointer = (unsigned long) char_array;
	
	for (i = 0; i < 5; i++) {
	printf("[hacky nonpointer] points to %p, which contains the char %c\n", hacky_nonpointer, *((char *)hacky_nonpointer));
	hacky_nonpointer = hacky_nonpointer + sizeof(char);
	}
	
	hacky_nonpointer = (unsigned long) int_array;
	
	for (i = 0; i < 5; i++) {
	printf("[hacky nonpointer] points to %p, which contains the integer '%d'\n", hacky_nonpointer, *((int *)hacky_nonpointer));
	hacky_nonpointer = hacky_nonpointer + sizeof(int);
	}
	return 0;
}
```

In the original book they used unsigned short to simulate pointers. On 64 bit system we can simulate it using `long` because the pointer is 64 bits in size. We then use `sizeof` operator to simulate pointer arithmetic. Then we simply cast the non-pointer as pointer of correct type and dereference the address. This means that variable of any type can be typecasted as different type. 
# Command line arguments
Using command line arguments can be more convenient to pass initial parameters to the program  instead of using `scanf()`. To pass these arguments the main function must be equipped with two parameters: an integer and pointer to an array of strings.
```c
#include <stdio.h>
#include <string.h>

int main(int arg_count, char *arg_list[]) {
	int i;
printf("There are %d arguments provided:\n", arg_count);
	for (i=0; i < arg_count; i++) {
		printf("argument #%d\t-\t%s\n", i, arg_list[i]);
	}
}
```
The output will be:
```sh
bobo@bobo-ws ➜ ./commandline this is a test
There are 5 arguments provided:
argument #0     -       ./commandline
argument #1     -       this
argument #2     -       is
argument #3     -       a
argument #4     -       test
```
The zeroth argument is always name of the binary. The arguments are stored in argument array (sometimes called argument vectors) and contains the arguments as strings.

If we wanted to use some of the arguments as integers, we would have to call special conversion function like `atai()` meaning ASCII to integer. This functions accept a pointer to a string as its argument and returns the integer value it represents:
```C
#include <stdio.h>
#include <stdlib.h>

void usage(char *program_name)
	{
	printf("Usage %s <message> <# of times to repeat>", program_name);
	exit(1);
}

int main(int arg_count, char *arg_list[]) {
	int i, count;
	
	if(arg_count < 3) //when arguments are less then 3 print usage info
		usage(arg_list[0]);
		
	count = atoi(arg_list[2]); //convert third argument into integer
	printf("Repeating %d times... \n", count); 
	//print second argument n times based on count variable from conversion
	for (i = 0; i < count; i++) {
		printf("%3d - %s\n", i, arg_list[1]);
	}
}
```
The output is the following:
```sh
bobo@bobo-ws ➜ ./convert 'hello, world', 3        
Repeating 3 times... 
  0 - hello, world,
  1 - hello, world,
  2 - hello, world,
bobo@bobo-ws ➜ ./convert                  
Usage ./convert <message> <# of times to repeat>%    
```
In the code above the `if` statement makes sure that three arguments are present. If we tried to access string that does not exist or the program does not have permission - the program will crash.

In C we need to make sure such situations are always handled by program logic. Memory violation can be explored by commenting out the `if` statement:
```c
#include <stdio.h>
#include <stdlib.h>

void usage(char *program_name)
	{
	printf("Usage %s <message> <# of times to repeat>", program_name);
	exit(1);
}

int main(int arg_count, char *arg_list[]) {
	int i, count;
	
	//if(arg_count < 3) //when arguments are less then 3 print usage info
	//	usage(arg_list[0]);
		
	count = atoi(arg_list[2]); //convert third argument into integer
	printf("Repeating %d times... \n", count); 
	//print second argument n times based on count variable from conversion
	for (i = 0; i < count; i++) {
		printf("%3d - %s\n", i, arg_list[1]);
	}
}
```

When executing this code with improper parameters, the result will be segmentation fault:
```sh
bobo@bobo-ws ➜ ./convert2 test
[1]    22617 segmentation fault (core dumped)  ./convert2 test
```
The program tried to access element of the array that does not exist. This results in crash due to segmentation fault. The memory is segmented and some memory segments are not within the boundaries of the memory segments, that the program is given access to. When the program tries to access out of bounds memory addresses it will crash due to segmentation fault. This can be examined using `gdb` :
```sh
(gdb) x/3xg 0x7fffffffd908
0x7fffffffd908: 0x00007fffffffdd58      0x00007fffffffdd89
0x7fffffffd918: 0x0000000000000000
```
After the segmentation fault the program is paused and we can use `gdb` to examine the address of the argument vector. As we see first two addresses are valid. But third address is all zero and this will cause the crash, because it is out of bounds.
# Variable scoping
In C variables have scope or context. Each function can have its own local variables that are accessible only within the function. In fact this local variable will be instantiated as different variable for each call of the function. Meaning each call will have its own unique local variables.

Globally scoped variables are accessible from anywhere of the program. They are defined outside of any function and can be accessed by any function. Any changes to global variable will persist and changes will be visible by other functions.

If we name local variable the same as global variable, the compiler will prefer the local variable when dealing with local functions and global variables:

```c
#include <stdio.h>

int j = 42; //global variable

void func3() {
    int i = 11, j = 999; //Here j is local variable of func3
    printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j);
}


void func2() {
    int i = 7;
    printf("\t\t[in func2] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t[in func2] j @ 0x%08x = %d\n", &j, j);
    printf("\t\t[in func2] setting j = 1337\n");
    j = 1337; //writing to j
    func3();
    printf("\t\t[back in func2] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t[back in func2] j @ 0x%08x = %d\n", &j, j);
}

void func1() {
    int i = 5;
    printf("\t[in func1] i @ 0x%08x = %d\n", &i, i);
    printf("\t[in func1] j @ 0x%08x = %d\n", &j, j);
    printf("\t[in func2] setting j = 1337\n");
    func2();
    printf("\t[back in func1] i @ 0x%08x = %d\n", &i, i);
    printf("\t[back in func1] j @ 0x%08x = %d\n", &j, j);
}

int main() {
    int i = 3;
    printf("[in main] i @ 0x%08x = %d\n", &i, i);
    printf("[in main] j @ 0x%08x = %d\n", &j, j);
    func1();
    printf("[back in main] i @ 0x%08x = %d\n", &i, i);
    printf("[back in main] j @ 0x%08x = %d\n", &j, j);
}
```
The output of this code is:
```sh
obo@bobo-ws ➜ ./scope3                     
[in main] i @ 0xe98c8484 = 3
[in main] j @ 0xff3fc028 = 42
        [in func1] i @ 0xe98c8464 = 5
        [in func1] j @ 0xff3fc028 = 42
        [in func2] setting j = 1337
                [in func2] i @ 0xe98c8444 = 7
                [in func2] j @ 0xff3fc028 = 42
                [in func2] setting j = 1337
                        [in func3] i @ 0xe98c8420 = 11
                        [in func3] j @ 0xe98c8424 = 999
                [back in func2] i @ 0xe98c8444 = 7
                [back in func2] j @ 0xff3fc028 = 1337
        [back in func1] i @ 0xe98c8464 = 5
        [back in func1] j @ 0xff3fc028 = 1337
[back in main] i @ 0xe98c8484 = 3
[back in main] j @ 0xff3fc028 = 1337
```
In this output is is evident that in `func3` the `j` is different from the global variable `j`. Notice that the address for  local `j` is different from global `j` variant.

This can be further explored using `gdb` backtrace command (page 66. Art of Exploit.).

## Static variables
Static variables are similar to global variables in that they remain intact between function calls. Static variables are initialized only once. They are declared using keyword static:
```c
static int static_var = 42;
```
Different function context windows (scopes) can have static variables sharing name. Each will be assigned with memory space of that function scope. The static variable is local to its scope (including global static variables and then it is localized in global scope).

# Memory Segmentation
Compiled program's memory is segmented into five segments:
* `text`
* `data`
* `bss`
* `heap`
* `stack`
The text segment is also called code segment. This is because this is where the machine instruction of the program itself are loaded. The execution of this segment is non-linear thanks to high level control structures that are compiled into branching, jump and call instructions in assembly language. As a program executes, the RIP is set to the first instruction in the text segment. The processor then follows an execution loop:
1. Reads the instruction that RIP is pointing to
2. Adds the byte length of the instruction into RIP
3. Executes the instruction that was read in step 1
4. Goes back to step 1
This execution process works the same regardless of changes to RIP. When instruction executed in step 3 changes RIP, the processor does not care and will go to step 1. The processor expects non linear execution.

Write permissions for `text` segment is disabled as it stores only code. Attempts to write to this segment will result in the process being killed and user notified by system. The size of this segment is fixed. The program can also thanks to read only property of this segment be executed multiple times.

## Variables
The `bss` and `data` segments are used to store global and static program variables. The `data` segment is filled with the uninitialized global and static variables, while `bss` contains uninitialized counterparts.

These segments are writable but they have fixed size. The reason global and static variables can persist is because they have their own dedicated segments.
## Heap segment
The `heap` segment is block of memory the programmer can directly control. The use of this segment is for programmers needs. It is not of fixed size.

The heap is managed using allocating and deallocating algorithms. They reserve and free locations in this memory segment. The heap grows down towards larger address values.
## The Stack
The stack is also variable in size and is reserved for local variables and local function scopes. This is what `gdb` backtrace is looking at. This is also when arguments passed onto functions are stored, the location the RIP should return to after the end of current scope, all local variables for that scope. All of this information is stored in what is called stack frame. Stack will contain many stack frames.

In general computing science the stack is an abstract data structure. It has FILO (first in last out) ordering. This means first item put in the stack is also the last one. Exactly like PEZ dispensers:
![[Pasted image 20240915224758.png]]
When we put item in stack we call it `pushing` and when we remove it is it called `popping`. 


The `RSP` register is used to keep track of the addresses at the end of the stack, which is constantly changing as the program executes. The stack is growing towards lower addresses in the memory. 

The FILO system is very good for storing context information. When function is called several items are pushed onto the stack together in the stack frame. The `RPB` register sometimes called frame pointer `FP` register or local base LB pointer - is used to store reference to local function variables in the current stack frame. Each stack frame contains the parameters to the function, its local variables and two pointers that are necessary to put things back together: the saved frame pointer (`SFP`) and the return address. The `SFP` is used to restore `RPB` to its previous value and return address is used to restore `RIP` to the next instruction found after the function call. This restores the functional context of the previous stack frame.

The following is the example for this behavior:
```c
void test_function(int a, int b, int c, int d) {
    int flag;
    char buffer[10];

    flag = 31337;
    buffer[0];
}

int main() {
    test_function(1, 2, 3, 4);
}
```

The `test_function` accepts 4 parameters, contains local integer flag variable and buffer of length 10. The variables and the parameters are stored in stack frame while the code itself is in `text` segment of memory:
```sh
(gdb) disass main
Dump of assembler code for function main:
   0x000000000000117a <+0>:     push   rbp
   0x000000000000117b <+1>:     mov    rbp,rsp
   0x000000000000117e <+4>:     mov    ecx,0x4 //push params to registers
   0x0000000000001183 <+9>:     mov    edx,0x3
   0x0000000000001188 <+14>:    mov    esi,0x2
   0x000000000000118d <+19>:    mov    edi,0x1
   0x0000000000001192 <+24>:    call   0x1139 <test_function>
   0x0000000000001197 <+29>:    mov    eax,0x0
   0x000000000000119c <+34>:    pop    rbp
   0x000000000000119d <+35>:    ret
End of assembler dump.
(gdb) disass test_function 
Dump of assembler code for function test_function:
   0x0000000000001139 <+0>:     push   rbp
   0x000000000000113a <+1>:     mov    rbp,rsp
   0x000000000000113d <+4>:     sub    rsp,0x20
   0x0000000000001141 <+8>:     mov    DWORD PTR [rbp-0x14],edi
   0x0000000000001144 <+11>:    mov    DWORD PTR [rbp-0x18],esi
   0x0000000000001147 <+14>:    mov    DWORD PTR [rbp-0x1c],edx
   0x000000000000114a <+17>:    mov    DWORD PTR [rbp-0x20],ecx
   0x000000000000114d <+20>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000001156 <+29>:    mov    QWORD PTR [rbp-0x8],rax
   0x000000000000115a <+33>:    xor    eax,eax
   0x000000000000115c <+35>:    mov    DWORD PTR [rbp-0x10],0x7a69
   0x0000000000001163 <+42>:    nop
   0x0000000000001164 <+43>:    mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000001168 <+47>:    sub    rax,QWORD PTR fs:0x28
   0x0000000000001171 <+56>:    je     0x1178 <test_function+63>
   0x0000000000001173 <+58>:    call   0x1030 <__stack_chk_fail@plt>
```
In the disassembly dump we can see that the main function lives at address `0x000000000000117a` and the test_function starts at address `0x1139`. First few instructions of the main function set up the stack frame, this is called function prologue or procedure prologue. Every function has this prologue to set up the frame. They save the frame pointer on the stack, and they save the stack memory for the local function variables. Sometimes the function prologue does stack alignment as well. The produced prologue will be dependent on compiler used and its settings.

When the program is run the `main()` function is called, which simply calls `test_function()`. When the `test_function()` is called, various values are pushed to the stack to create the start of the stack frame. The function parameters are pushed onto the stack in reverse order (since it is FILO). The arguments provided are 1,2,3,4 so onto the stack it will be pushed as 4,3,2,1. This corresponds to d,c,b and a argument names for that function.

Since this code is compiled for `AMD64`, the convention is first six arguments to function call are moved to registers in a function call. 

The call instruction stores the return address on the stack and jumps `RIP` to the beginning of the `test_function`. This causes the prologue of the function to be executed. In this step the value of `RPB` register is pushed onto the stack. This value is called the saved frame pointer (`SFP`) and is later used to restore `RPB` back to its original state.

The current value of `RSP` is then copied into `RBP` to set new frame pointer. This frame pointer is used to reference local variables of the function (flag and buffer).
### Local function execution detail
#### Entry into main
First the `RIP` is set to the address of main and then first few instructions set up the stack frame. This is known as function prologue:
```asm
0x000000000000117a <+0>:    push   rbp
0x000000000000117b <+1>:    mov    rbp,rsp
```

In this code we first push current `rpb` value to the stack (this we call saved stack pointer) and it is later used to restore `RBP` back to original form. Then the current value of `rsp` is copied into `rpb` to set new stack frame pointer. 

At this point:
- **`RSP`** points to the **top of the stack**, where local variables or other data will be allocated.
- **`RBP`** points to the **base** of the stack frame for `main()`.
#### Preparing for the function call
Before calling the function, variables are stored into registers according to the **System V AMD64 ABI** calling convention:
```asm
0x000000000000117e <+4>:    mov    ecx,0x4  ; 4th argument in ECX
0x0000000000001183 <+9>:    mov    edx,0x3  ; 3rd argument in EDX
0x0000000000001188 <+14>:   mov    esi,0x2  ; 2nd argument in ESI
0x000000000000118d <+19>:   mov    edi,0x1  ; 1st argument in EDI
```
This simply moves values into each register.
#### Calling the function:
The `call` instruction is used to call `test_function()`:
```asm
0x0000000000001192 <+24>:   call   0x1139 <test_function>
```
The call instruction pushes the return address 
### Examination of stack frame building
We can watch the stack frame construction on the stack using `gdb`. We set breakpoints at the call of `test_function` and at the beginning of the function body. The second breakpoint will be situated after the function prologue:
```sh
bobo@bobo-ws ➜ gdb -q ./stack_example 
Reading symbols from ./stack_example...
(gdb) list
1       void test_function(int a, int b, int c, int d) {
2           int flag;
3           char buffer[0];
4
5           flag = 31337;
6           buffer[0];
7       }
8
9       int main() {
10          test_function(1, 2, 3, 4);
(gdb) break 10
Breakpoint 1 at 0x117e: file stack_example.c, line 10.
(gdb) break test_function 
Breakpoint 2 at 0x114d: file stack_example.c, line 1.
(gdb) run
Starting program: /home/bobo/Projects/C/C_To_Assembly/src/stack_example 
Breakpoint 1, main () at stack_example.c:10
10          test_function(1, 2, 3, 4);
(gdb) i r rsp rbp rip
rsp            0x7fffffffd770      0x7fffffffd770
rbp            0x7fffffffd770      0x7fffffffd770
rip            0x55555555517e      0x55555555517e <main+4>
(gdb) x/5i $rip
=> 0x55555555517e <main+4>:     mov    ecx,0x4
   0x555555555183 <main+9>:     mov    edx,0x3
   0x555555555188 <main+14>:    mov    esi,0x2
   0x55555555518d <main+19>:    mov    edi,0x1
   0x555555555192 <main+24>:    call   0x555555555139 <test_function>
```

Currently the `rsp` (stack pointer) is top of the stack. This means bottom of this newly created stack will be set to the top of previous stack: `0x7fffffffd770`. 
The next breakpoint is set after the procedure prologue, so the new stack frame will be built. It can be examined like this:
```sh
(gdb) cont
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:1
1       void test_function(int a, int b, int c, int d) {
(gdb) disass test_function 
Dump of assembler code for function test_function:
   0x0000555555555139 <+0>:     push   rbp
   0x000055555555513a <+1>:     mov    rbp,rsp
   0x000055555555513d <+4>:     sub    rsp,0x20
   0x0000555555555141 <+8>:     mov    DWORD PTR [rbp-0x14],edi
   0x0000555555555144 <+11>:    mov    DWORD PTR [rbp-0x18],esi
   0x0000555555555147 <+14>:    mov    DWORD PTR [rbp-0x1c],edx
   0x000055555555514a <+17>:    mov    DWORD PTR [rbp-0x20],ecx
=> 0x000055555555514d <+20>:    mov    rax,QWORD PTR fs:0x28
   0x0000555555555156 <+29>:    mov    QWORD PTR [rbp-0x8],rax
   0x000055555555515a <+33>:    xor    eax,eax
   0x000055555555515c <+35>:    mov    DWORD PTR [rbp-0x10],0x7a69
   0x0000555555555163 <+42>:    nop
   0x0000555555555164 <+43>:    mov    rax,QWORD PTR [rbp-0x8]
   0x0000555555555168 <+47>:    sub    rax,QWORD PTR fs:0x28
   0x0000555555555171 <+56>:    je     0x555555555178 <test_function+63>
   0x0000555555555173 <+58>:    call   0x555555555030 <__stack_chk_fail@plt>
--Type <RET> for more, q to quit, c to continue without paging--c
   0x0000555555555178 <+63>:    leave
   0x0000555555555179 <+64>:    ret
End of assembler dump.
(gdb) i r rsp rbp rip
rsp            0x7fffffffd740      0x7fffffffd740
rbp            0x7fffffffd760      0x7fffffffd760
rip            0x55555555514d      0x55555555514d <test_function+20>
(gdb) x/16xg $rsp
0x7fffffffd740: 0x0000000300000004      0x0000000100000002
0x7fffffffd750: 0x0000000000000000      0x00007ffff7fe53e0
0x7fffffffd760: 0x00007fffffffd770      0x0000555555555197
0x7fffffffd770: 0x00007fffffffd810      0x00007ffff7dc1e08
0x7fffffffd780: 0x00007fffffffd7c0      0x00007fffffffd898
0x7fffffffd790: 0x0000000155554040      0x000055555555517a
0x7fffffffd7a0: 0x00007fffffffd898      0x4c805c0685dc0b07
0x7fffffffd7b0: 0x0000000000000001      0x0000000000000000
```
After the execution finishes, the entire stack frame is popped off the stack and the `RIP` register is set to the return address so the program can continue. If another function was to be called within new stack frame,  another stack frame would be pushed onto the stack. As each function ends, its stack frame is popped off the stack, so execution can be returned to the previous function. This behavior is the reason the stack is organized as FILO structure. The various segments of memory are arranged in order they were presented, from lower memory address to higher.

The stack grows from higher address values to lower, while heap is growing from lower address to higher. Both are dynamically allocated.

## Memory segments in C
The compiled code goes into the code segment of memory while variables reside on the rest. Variables defined outside functions are considered global and variables that are static have their own storage considerations.

Global and static variables with assigned values are stored in data segment. Global and static variables that are declared but not initialized are stored in the `bss` segment. Memory on the `heap` must be allocated by the programmer using allocator function called `malloc`.

Usually pointers are used to reference memory on the heap. Finally, the remaining function variables are stored on the stack. Since variables on stack live in their stack frames, this ensures each local variable can have unique context. This can be explored in this code:
```c
#include <stdio.h>
#include <stdlib.h>

int global_var;
int global_initialized_var = 5;

void function() { 
    int stack_var; //var local to this func
    printf("stack_var is at address 0x%016lx\n", &stack_var);
}

int main() {
    int stack_var;
    static int static_initialized_var = 5;
    static int static_var;
    int *heap_var_ptr;

    heap_var_ptr = (int *) malloc(4);

    //these variables are in data segment
    printf("global_initialized var is at address 0x%016lx\n", &global_initialized_var);
    printf("static_initialized_var is at address 0x%016lx\n\n", &static_initialized_var);

    //variables in bss segment
    printf("static_var is at address 0x%016lx\n", &static_var);
    printf("global_var is at address 0x%016lx\n\n", &global_var);

    //the heap segment
    printf("heap_var_ptr is at address 0x%016lx\n\n", heap_var_ptr);

    //The stack
    printf("stack_var is at address 0x%016lx\n\n", stack_var);

    function();
}
```
The output is:
```sh
global_initialized var is at address 0x0000654898a73028
static_initialized_var is at address 0x0000654898a7302c

static_var is at address 0x0000654898a73038
global_var is at address 0x0000654898a73034

heap_var_ptr is at address 0x00006548c45222a0

stack_var is at address 0x00007ffd2cba9e5c

stack_var is at address 0x00007ffd2cba9e34
```
The heap variable is declared as integer pointer which will point to memory allocated by the memory allocator `malloc`. The `malloc` function is used to allocate 4 bytes on heap. Since the newly allocated memory can be of any type the return is void pointer. This needs to be typecasted as integer pointer.

The first two addresses have lowest value, because they are in data segment. The next two are stored in the `bss`segment, because they are not initialized. These addresses are very close to each other, because  both segments are fixed in size.

The heap has higher value, because it is located below the `bss` segment towards higher value. The stack variables have the highest values, because they the stack starts at highest address and grows toward lower address.

The memory address of the local stack variable is lower, because as each function is called new stack frame is popped and the address grows toward heap with each new stack frame.

## Using heap
Heap is allocated using `malloc` function. It takes number of bytes as its only argument and returns the start address of the allocated heap as void pointer. If the allocation fails for some reason, `malloc` will return NULL pointer with value of 0.

The corresponding deallocator is function called `free` and it accept the pointer to the start of heap as its argument. The allocator handles the management internally, so it knows how large the segment to be freed is. Here is an example of using heap:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int global_var;
int global_initialized_var = 5;

int main(int argc, char *argv[]) {
    char *char_ptr;
    int *int_ptr;
    int mem_size;

    if (argc < 2) //If there are not any commands
    {
        mem_size = 50; //Use 50 as the default
    }
    else {
        mem_size = atoi(argv[1]); //convert argument into integer
    }
    
    printf("\t[+] allocating %d bytes on the heap for char_ptr\n", mem_size);
    char_ptr = (char *) malloc(mem_size); //Allocate to memory heap

    if(char_ptr == NULL) { //Error checking, in case malloc fails
        fprintf(stderr, "Error: could not allocate memory heap\n");
        exit(-1);
    }

    strcpy(char_ptr, "This memory is located on the heap.");
    printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

    printf("\t[+] allocating 12 bytes of memory on the heap for int_ptr\n");
    int_ptr = (int *) malloc(12);

    if(int_ptr == NULL) //Erro check
    {
        fprintf(stderr, "Error: could not allocate memory heap\n");
        exit(-1);
    }

    *int_ptr = 31337; //Put the value of 31337 where int_ptr is pointing
    printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);


    printf("\t[-] freeing char_ptr heap memory...\n");
    free(char_ptr);

    printf("\t[+] allocating another 15 bytes for  char_ptr\n");
    char_ptr = (char *) malloc(15);

    if(char_ptr == NULL) //Erro check
    {
        fprintf(stderr, "Error: could not allocate memory heap\n");
        exit(-1);
    }

    strcpy(char_ptr, "new memory");
    printf(" char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

    printf("\t[-] freeing int_ptr heap memory\n");
    free(int_ptr);
    printf("\t[-] free char_ptr heap memory");
    free(char_ptr);
}
```
This program accepts an argument that define size of the memory to be allocated, with default of 50. It demonstrates using `malloc` and `free` with `printf` statements that show what is happening.

The `malloc` function does not know what type it is allocating memory for it returns void pointer and must be typecasted to proper type. After every `malloc` we perform error check whether the pointer is null. The `fprintf` function is to print standard error message and then the program is exited with error code.

The `fprintf` is similar to `printf` but it accepts as first argument `stderr` which is standard filestream for error display.
```sh
bobo@bobo-ws ➜ ./heap_example    
        [+] allocating 50 bytes on the heap for char_ptr
char_ptr (0x5a1340c196b0) --> 'This memory is located on the heap.'
        [+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x5a1340c196f0) --> 31337
        [-] freeing char_ptr heap memory...
        [+] allocating another 15 bytes for  char_ptr
 char_ptr (0x5a1340c19710) --> 'new memory'
        [-] freeing int_ptr heap memory
        [-] free char_ptr heap memory% 
```
Notice that each memory address is higher then previous ones. Even when the first 50 bytes were deallocated, the next allocation uses higher address.
```sh
bobo@bobo-ws ➜ ./heap_example 1200
        [+] allocating 1200 bytes on the heap for char_ptr
char_ptr (0x5af627fe66b0) --> 'This memory is located on the heap.'
        [+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x5af627fe6b70) --> 31337
        [-] freeing char_ptr heap memory...
        [+] allocating another 15 bytes for  char_ptr
 char_ptr (0x5af627fe66b0) --> 'new memory'
        [-] freeing int_ptr heap memory
        [-] free char_ptr heap memory%   
```
If a larger block is allocated and then deallocated, the final 15 byte allocation will occur in that freed memory space. With this debugging setup we can find exactly when this change occurs. This can be different between 32 and 64 bit systems. Experimentation is needed.
### Error checked `malloc`\
It is good idea to wrap `malloc` in custom error checked function, that handles checking if the pointer is null.