In C execution of programs begins with main function. The program is compiled using gcc under linux with following command:
```sh
gcc myprog.c
```
This will compile the program and create a.out as our binary output. This is our executable. The compiler creates binary instructions for the computer to use. Such instructions are not legible for people to read, so we can use disassembly to see the corresponding assembly instructions. Assembly language is just human readable representation of the machine code.

When we have our compiled object, we can use `objdump` to view the disassembly. We can use it together with grep to view creation length after an regular expression:
```sh
objdump a.out -D C_To_Asm | grep -A20 main.:
000000000001139 <main>:  
   1139:       55                      push   %rbp  
   113a:       48 89 e5                mov    %rsp,%rbp  
   113d:       48 8d 05 c0 0e 00 00    lea    0xec0(%rip),%rax        # 2004 <_IO_stdin_used+0x4>  
   1144:       48 89 c7                mov    %rax,%rdi  
   1147:       e8 e4 fe ff ff          call   1030 <puts@plt>  
   114c:       b8 00 00 00 00          mov    $0x0,%eax  
   1151:       5d                      pop    %rbp  
   1152:       c3                      ret  
  
Disassembly of section .fini:  
  
0000000000001154 <_fini>:  
   1154:       f3 0f 1e fa             endbr64  
   1158:       48 83 ec 08             sub    $0x8,%rsp  
   115c:       48 83 c4 08             add    $0x8,%rsp  
   1160:       c3                      ret  
  
Disassembly of section .rodata:  
  
0000000000002000 <_IO_stdin_used>:
```

The first column of the output after the matched expression for example `<main>:` represents memory address in hexadecimal notation. The next column are machine code instructions in hexadecimal byte notation. Hexadecimal format is used because it is more readable then binary. On the right column are assembly language instructions. Assembly language is collection of mnemonics representing the underlying machine code instructions.

Each processor architecture can have its own set of machine code instructions and therefore its own version of assembly language. In the world of `x86` architecture we have two dominant types of assembly: AT&T and Intel syntax assembly. They can be spotted apart by Intel syntax being cleaner to read without many special characters.

The `objdump` command can be changed to display disassembly in Intel format by using option `-M intel`. 

## The `x86` processor
The 8086 CPU was the first `x86` processor. It was made by Intel. The naming scheme of later processors ended with 86: 80186, 80286, etc... The `x86` has several internal registers, that are like variables for the processor.

We can use `gdb` to see the values of those registers. We can run a binary with debug symbols. With `gdb` we can set breakpoints and examine the registers:
```sh
bobo@bobo-ws ➜ gdb -q ./C_To_Asm   
Reading symbols from ./C_To_Asm...  
(gdb) break main  
Breakpoint 1 at 0x113d: file /home/bobo/Projects/C/C_To_Asm/main.c, line 6.  
(gdb) run  
Starting program: /home/bobo/Projects/C/C_To_Asm/bin/Debug/C_To_Asm    
  
Breakpoint 1, main () at /home/bobo/Projects/C/C_To_Asm/main.c:6  
6           printf("Hello world!\n");  
(gdb) info registers  
rax            0x555555555139      93824992235833  
rbx            0x7fffffffda48      140737488345672  
rcx            0x555555557dd8      93824992247256  
rdx            0x7fffffffda58      140737488345688  
rsi            0x7fffffffda48      140737488345672  
rdi            0x1                 1  
rbp            0x7fffffffd920      0x7fffffffd920  
rsp            0x7fffffffd920      0x7fffffffd920  
r8             0x0                 0  
r9             0x7ffff7fcb200      140737353921024  
r10            0x7fffffffd650      140737488344656  
r11            0x203               515  
r12            0x1                 1  
r13            0x0                 0  
r14            0x7ffff7ffd000      140737354125312  
r15            0x555555557dd8      93824992247256  
rip            0x55555555513d      0x55555555513d <main+4>  
eflags         0x246               [ PF ZF IF ]  
cs             0x33                51  
ss             0x2b                43  
ds             0x0                 0  
es             0x0                 0  
fs             0x0                 0  
gs             0x0                 0  
fs_base        0x7ffff7d99740      140737351620416  
gs_base        0x0                 0  
(gdb) quit  
A debugging session is active.  
  
       Inferior 1 [process 32253] will be killed.  
  
Quit anyway? (y or n) y
```
With command `info registers` or simply `ir` we can examine the registers of the CPU and their values. The first four registers (`AEX, ACX, EDX and EBX`) are known as general purpose registers. These are called Accumulator, Counter, Data and Base. They are generally used as temporary values when the computer is executing its machine code instructions.

The second set of registers (`ESP, EBP, ESI and EDI`). They are also general purpose registers but they are known as pointers and indexes. They stand for Stack Pointer, Base Pointer, Source Index and Destination Index. The pointer registers are used as pointer to memory addresses. They are 32 bit in size. These pointers are relevant to memory management. The indexes are also technically pointers and are commonly used to point to the source and destination when data needs to be read from or written to. There are load and store instructions that use these registers. But these registers can be thought of as general purpose also.

The `EIP` registers is the instruction pointer. It points to the current instruction the CPU is reading. This register will be used a lot in debugging.

The remaining `EFLAGS` register consists of several bit flags. They are used for comparison and memory segmentation. The actual memory is split into multiple different segments and these registers keep track of that. These registers are rarely needed to be accessed directly.

## Assembly language
First we can configure globally the `gdb` disassembly flavor by modifying file `~/.gdbinit`.
The assembly language in Intel syntax looks like this:
```asm
operation <destination>, <source>
```
The destination and source will either be register, a memory address or a value. The instructions are usually intuitive for example `mov` will move a value from the source to the destination. The `sub` will subtract, `inc` will increment and so forth. For example the following instructions will move value from `ESP` to `EBP` and then subtract 8 from `ESP` (storing the result in ESP):
```assembly
mov ebp, esp
sub esp,0x8
```
There are also operations that are used to control the flow of a program. The `cmp` operation is used to compare values. Basically any operation starting with `j` is jump operation that jumps to somewhere depending on the result of that operation.

The example below first compares a 4-byte value located at EBP minus 4 with the number 9. The next instruction is short for `jump if less than or equal to`, referring to the result of the previous comparison. If the value is less than or equal to 9, execution jumps to the instruction at `8048393`. Otherwise, execution flows to the next instruction with an unconditional jump. If the value is not less than or equal to 9, execution will jump to `80483a6`.
```asm
cmp DWORD PTR [ebp-4],0x9
jle 8048393 <main+x1f>
jmp 80483a6 <main+0x32>
```

We can use `gdb` to step through and examine our program. First we need to compile our program with debugging symbols using the `-g` parameter with `gcc`:
```sh
gcc -g myprog.c
```
To debug the program we can run the debugger with following command:
```sh
gdb -q ./a.out
```
With the debugger we can list the source code:
```sh
(gdb) list:
1       #include <stdio.h>  
2       #include <stdlib.h>  
3  
4       int main()  
5       {  
6           int i;  
7           for(i = 0; i < 10; i++)  
8           {  
9               puts("Hello World!\n");  
10          }  
11          return 0;  
12      }
```
The list size is configurable. We can than disassemble the code with following command:
```sh
(gdb) disassemble main  
Dump of assembler code for function main:  
  0x0000000000001139 <+0>:     push   rbp  
  0x000000000000113a <+1>:     mov    rbp,rsp  
  0x000000000000113d <+4>:     sub    rsp,0x10  
  0x0000000000001141 <+8>:     mov    DWORD PTR [rbp-0x4],0x0  
  0x0000000000001148 <+15>:    jmp    0x115d <main+36>  
  0x000000000000114a <+17>:    lea    rax,[rip+0xeb3]        # 0x2004  
  0x0000000000001151 <+24>:    mov    rdi,rax  
  0x0000000000001154 <+27>:    call   0x1030 <puts@plt>  
  0x0000000000001159 <+32>:    add    DWORD PTR [rbp-0x4],0x1  
  0x000000000000115d <+36>:    cmp    DWORD PTR [rbp-0x4],0x9  
  0x0000000000001161 <+40>:    jle    0x114a <main+17>  
  0x0000000000001163 <+42>:    mov    eax,0x0  
  0x0000000000001168 <+47>:    leave  
  0x0000000000001169 <+48>:    ret  
End of assembler dump.
```
Then we can set a breakpoint at the start of the main function:
```sh
(gdb) break main  
Breakpoint 1 at 0x1141: file /home/bobo/Projects/C/C_To_Asm/main.c, line 7.
```
The breakpoint causes the program in the debugger to pause. After the breakpoint is hit using `run` command we can examine the `EIP` (or `RIP` on 64 bit) register using `info register rip` command:
```sh
(gdb) info register rip  
rip            0x555555555141      0x555555555141 <main+8>
```
The `EIP or RIP` register contains a memory address that points to an instruction in the `main()` function disassembly. This should point to the instruction `0x0000000000001141 <+8>:     mov    DWORD PTR [rbp-0x4],0x0  ` The instructions previous to this one are called `function prologue` and are generated by the compiler to setup the memory for the rest of the `main()` function.

Part of the reason why in C the variables must be declared is to aid with the process of setting up the instructions. 

### Address examination

The program allows for examination of a memory address with command `x` or `examine`. The examine command expects two arguments when it is used: the location of the memory and how to display it. The display can be controlled with format specifying parameters:
* `o` Display in octal
* `x` Display in hexadecimal
* `u` Display in unsigned, standard base-10 decimal
* `t` Display in binary
These can be used with the examine command to examine a certain memory address. The register for example `rip` is containing an value:
```sh
> i r rip
rip            0x55555555514a      0x55555555514a <main+17>
```
The above command requests info from register `rip` and prints its contents. This register contains address of an memory to which `rip` is pointing to. We can also reference the address stored at the register directly using `$rip` syntax is equivalent to the value the register is currently storing.
We can then examine the address with the `x` command and use the letters to specify numerical format:
```sh
> x/x 0x55555555514a
0x55555555514a <main+17>:	0xb3058d48
> x/x $rip
0x55555555514a <main+17>:	0xb3058d48
```
> [!tip] Notice that the above command result in same output because of the register reference `$rip`

Below we can see the output for each output format:
```sh
> x/x $rip
0x55555555514a <main+17>:	0xb3058d48
> x/o $rip
0x55555555514a <main+17>:	026301306510
> x/u $rip
0x55555555514a <main+17>:	3003485512
> x/t $rip
0x55555555514a <main+17>:	10110011000001011000110101001000
```

We can prepend the format letter with number to examine multiple units of memory at the address down the stack:
```sh
> x/2x $rip
0x55555555514a <main+17>:	0xb3058d48	0x4800000e
> x/12x $rip
0x55555555514a <main+17>:	0xb3058d48	0x4800000e	0xd7e8c789	0x83fffffe
0x55555555515a <main+33>:	0x8301fc45	0x7e09fc7d	0x0000b8e7	0xc3c90000
0x55555555516a:	0x0ff30000	0x8348fa1e	0x834808ec	0x00c308c4
```

The default size of a single memory unit is something called `word`. Usually it is four-byte in size. The size of the output can be controlled with size letter after the format letter:
* `b` a single byte
* `h` a half word, which is two bytes
* `w` a 4 byte word
* `g` a giant, 8 byte in size
Here is an example of printing with different size words:
```sh
> x/8xb $rip
0x55555555514a <main+17>:	0x48	0x8d	0x05	0xb3	0x0e	0x00	0x00	0x48
> x/8xh $rip
0x55555555514a <main+17>:	0x8d48	0xb305	0x000e	0x4800	0xc789	0xd7e8	0xfffe	0x83ff
> x/8xw $rip
0x55555555514a <main+17>:	0xb3058d48	0x4800000e	0xd7e8c789	0x83fffffe
0x55555555515a <main+33>:	0x8301fc45	0x7e09fc7d	0x0000b8e7	0xc3c90000
> x/8xg $rip
0x55555555514a <main+17>:	0x4800000eb3058d48	0x83fffffed7e8c789
0x55555555515a <main+33>:	0x7e09fc7d8301fc45	0xc3c900000000b8e7
0x55555555516a:	0x8348fa1e0ff30000	0x00c308c4834808ec
0x55555555517a:	0x0000000000000000	0x0000000000000000
```

Notice that as the `word` size is getting larger, the value are being reversed. So the `0x48` and `0x8d` becomes `0x8d48` as the order is reversed. This is because `x86` stores value in little-endian byte order. This means the least significant byte is stored first.

For example if four bytes are to be interpreted as single value, the bytes must be used in reverse order. The byte order of any architecture is very important to keep in mind.

The examine command can be also used with option `i` to see what assembly instruction is being stored at a register:
```sh
> x/i $rip
=> 0x55555555514a <main+17>:	lea    rax,[rip+0xeb3]        # 0x555555556004
```

#### Examining C variable values at runtime debug session
With `dbg` we can check variables when debugging live. In our demo program we have declaration of variable `i` and then for loop that prints 10 times hello world string.

When set breakpoint at the start of our program in main, we can examine the current instruction stored in `rip` register and also we can see the instruction in its hex form:
```sh
> x/i $rip
=> 0x555555555141 <main+8>:	mov    DWORD PTR [rbp-0x4],0x0
> x/7xb $rip
0x555555555141 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00
```
The instruction above corresponds to assigning 0 to the variable `i` in our C code. We can check with `objdump` to see the actual instruction is matching above:
```sh
   1141:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
```

The instructions move value of `0x0` into memory address stored in register `rbp` minus 4. This is because integer is defined as having 4 bytes of memory. So this will basically zero out the variable. When we examine the value before this instruction is executed, the memory will contain random garbage:
```sh
> i r rbp
rbp            0x7fffffffe300      0x7fffffffe300
> x/4xb 0x7fffffffe300
0x7fffffffe300:	0xa0	0xe3	0xff	0xff
```
In the commands above we examined the address stored at `rbp` register and examined it to show the contents. The contents are random garbage. The `rbp` register is shown to contain address `0x7fffffffe300` and the assembly instruction will be writing value offset by 4 less than that: `0x7fffffffe2fc`. The debugger can do these kinds of calculations on the fly:
```
> x/4xb $rbp - 4
0x7fffffffe2fc:	0xff	0x7f	0x00	0x00
```

However there is better way to examine the changing value that is less verbose. There is `dbg` command `print` that can be used to do simple calculations and store the outcome in temporary variable. This variable `$1` can be used to quickly access particular location at memory:
```sh
> print $rbp-4
$1 = (void *) 0x7fffffffe2fc
> x/4xb $1
0x7fffffffe2fc:	0xff	0x7f	0x00	0x00
> x/xw $1
0x7fffffffe2fc:	0x00007fff
```
> [!tip] Notice that the latest command is in reverse because of little-endian notation of the `x86` architecture.

We can then execute current instruction using command `nexti`. This will move our program to next instruction. The processor will read the instruction stored at `rip`, execute it and advance to next one. We can then inspect with our temporary value from `print`. When we do this the 4 bytes reserved for our variable `i` will get zeroed out:
```sh
> x/4xb $1
0x7fffffffe2fc:	0x00	0x00	0x00	0x00
> x/i $rip
=> 0x555555555148 <main+15>:	jmp    0x55555555515d <main+36>
```

### How the loop works under the hood:
```asm
0x55555555515d	cmp    DWORD PTR [rbp-0x4],0x9
0x555555555161	jle    0x55555555514a <main+17>
```
The first building block of the loop is compare operation. It compares our variable `i` with value of `9`. The next instruction `jle` stands for `jump if less than or equal to`, it uses the result of the previous operation that is stored in the `EFLAGS` register to jump `rip` to point to different part of code (if the destination of previous compare operation is less than or equal to the source).

In this case it says to jump to `0x55555555514a` if the value of `i` is less than or equal to 9. If it is not the case, the `rip` will move to next instruction below it.

The whole code looks like this:
```asm
0x555555555139	push   rbp
0x55555555513a	mov    rbp,rsp
0x55555555513d	sub    rsp,0x10
0x555555555141	mov    DWORD PTR [rbp-0x4],0x0
0x555555555148	jmp    0x55555555515d <main+36>
0x55555555514a	lea    rax,[rip+0xeb3]        # 0x555555556004
0x555555555151	mov    rdi,rax
0x555555555154	call   0x555555555030 <puts@plt>
0x555555555159	add    DWORD PTR [rbp-0x4],0x1
0x55555555515d	cmp    DWORD PTR [rbp-0x4],0x9
0x555555555161	jle    0x55555555514a <main+17>
0x555555555163	mov    eax,0x0
0x555555555168	leave
0x555555555169	ret
```

If the value of `i` is less then or equal to `9` as seen on the line `0x555555555161` after the comparison line above, the next instruction jump is to location `0x55555555514a` where we can see instruction `lea` (`load effective address`) and it moves some value to the `rax` instruction and then we have `mov` instruction that move content of `rax` into `rdi`.

When we use `nexti` command to get after the execution of the `mov rdi, rax` so that we have in our `rip` register instruction for the system call we can examine what is stored at the register:
```sh
> i r rdi
rdi            0x555555556004      93824992239620
```
We can see the `rdi` register points to memory address `0x555555556004` so we can examine what is going on there now:
```sh
> x/2xw 0x555555556004
0x555555556004:	0x6c6c6548	0x6f57206f
> x/6xb 0x555555556004
0x555555556004:	0x48	0x65	0x6c	0x6c	0x6f	0x20
> x/6ub 0x555555556004
0x555555556004:	72	101	108	108	111	32
```
The results show values that have a hidden pattern. The memory contains ASCII character codes. The values are of bytes that correspond to ASCII table characters.
Thankfully `gdb` contains command that allows for examining ASCII characters. We can use the `c` command letter to automatically look up bytes in the ASCII table and `s` letter format will display the entire string of character data:
```sh
> x/6cb 0x555555556004
0x555555556004:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '
> x/s 0x555555556004
0x555555556004:	"Hello World!\n"
```

The next instruction uses the stored string in memory to print the stored value to the terminal:
```sh
> x/i $rip
=> 0x555555555154 <main+27>:	call   0x555555555030 <puts@plt>
```
When we call for the next instruction, the string is printed to output terminal using the `printf` function.

The `lea` instruction is called `load effective address`. The `lea` will compute a memory address using same methods as `mov` but instead of stores the computed address in its target register, instead of loading the contents of that address and storing it.

## Back to basics
