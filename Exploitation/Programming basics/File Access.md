There are two main ways of accessing files with C: file descriptors and filestreams. File descriptors use set of low level IO instructions and the filestream is form of buffered file access that builds on these low level instructions. This text will focus on the low level aspects of file access.

# File descriptor

^1b4b35

File descriptor is a process-unique identifier (handle) for a file or other I/O resource such as pipe or socket. The `fd` is a number that reference open files. Four common functions that use `fd` are `open()`, `close()`, `read()` and `write()`. All of these functions return -1 when there is an error.

The `open()` function opens a file for reading or writing and returns a file descriptor. The returned value is unique for the opened file, but it is simple integer value. The file descriptor is passed on as argument to the other functions like a pointer to the opened file.
For the `close()` function the `fd` is its only argument.

The `read()` and `write()` functions accept file descriptors, pointer to the data and number of bytes for that operation.

The `open()` function accepts pointer to the file name and series of predefined flags to specify access modes.

## The flags
The `sys/stat.h` and `fcntl.h` headers had to be included because they define flags that are used together with `oepn()` function. The first set of flags are found in `fcntl.h` and they are used to set the access mode:
* `O_RDONLY` - Open file in read only access
* `O_WRONLY` - Open file in write only access
* `O_RDWR` - Open for both read and write
These flags can be combined with logical bitwise operators. Several other optional parameters can be combined using logical OR gate. Few more common useful flags are:
* `O_APPEND` - Write data at the end of the file
* `O_TRUNC` - If the file exist, truncate the file to 0 length
* `O_CREAT` - Create the file if it does not exist

Bitwise operations combine bits using standard logic gates. If full 32-bit value is provided for bitwise operation, each bit will be operated upon individually.

The flags used for the `open()` function have values that correspond to single bits. This way they can be used with bitwise operators without destroying any value.
## File access Demo

^1e2306

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void usage(char *prog_name, char *filename)
{
    printf("Usage %s <data to add to %s>\n", prog_name, filename);
    exit(0);
}

void fatal(char *); //Handle fatal error
void *ec_malloc(unsigned int); //Error checked malloc;
int main(int argc, char *argv[])
{
    int fd; //file descriptor
    char *buffer, *datafile;

    buffer = (char *) ec_malloc(100);
    datafile = (char *) ec_malloc(20);
    strcpy(datafile, "/tmp/notes");

    if(argc < 2)
    {
        usage(argv[0], datafile); //When not enough arguments display usage
    }

    strcpy(buffer, argv[1]); //copy into buffer

    printf("[DEBUG] buffer  @%p: \'%s\'\n", buffer, buffer);
    printf("[DEBUG] datafile  @%p: \'%s\'\n", datafile, datafile);

    strncat(buffer, "\n", -1); //Add new line at the end
    //opening file
    fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR, S_IWUSR);
    if(fd == -1)
    {
        fatal("in main() while opening file");
    }
    printf("[DEBUG] file descriptor is %d\n", fd);
    //writing data
    if(write(fd, buffer, strlen(buffer)) == -1)
    {
        fatal("in main() while writing buffer to file");
    }
    //Closing the file
    if(close(fd) == -1)
    {
        fatal("in main() while closing file");
    }

    printf("Note has been saved.\n");
    free(buffer);
    free(datafile);
}

//Function that displays error message and exits the program
void fatal(char *message)
{
    char error_message[100];

    strcpy(error_message, "[!] Fatal error ");
    strncat(error_message, message, 83);
    perror(error_message);
    exit(-1);
}

//Error chekced malloc
void *ec_malloc(unsigned int size)
{
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL)
    {
        fatal("in ec_malloc() on memory allocation");
    }
    return ptr;
}

```
The `strlen()` function accepts a string and returns its length. It is used in combination with the `write()` function, since it needs to know how many bytes to write. The `perror()` function is used to print the program error with possible additional information when available.
```sh
bobo@bobo-ws ➜ gcc -o simplenote simplenote.c
bobo@bobo-ws ➜ ./simplenote "this is a note" 
[DEBUG] buffer  @0x63a52db482a0: 'this is a note'
[DEBUG] datafile  @0x63a52db48310: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
bobo@bobo-ws ➜ ./simplenote "another write" 
[DEBUG] buffer  @0x5e59926042a0: 'another write'
[DEBUG] datafile  @0x5e5992604310: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
bobo@bobo-ws ➜ cat /tmp/notes
this is a note
another write
```

## Flags demo
```c
#include <stdio.h>
#include <fcntl.h>

void display_flags(char *, unsigned int);
void binary_print(unsigned int);

int main(int argc, char *argv[])
{
    display_flags("O_RDONLY\t\t", O_RDONLY);
    display_flags("O_WRONLY\t\t", O_WRONLY);
    display_flags("O_RDWR\t\t", O_RDWR);
    printf("\n");
    display_flags("O_APPEND\t\t", O_APPEND);
    display_flags("O_TRUNC\t\t", O_TRUNC);
    display_flags("O_CREAT\t\t", O_CREAT);
    printf("\n");
    display_flags("O_WRONLY|O_CREAT|O_APPEND", O_WRONLY|O_CREAT|O_APPEND);

}

void display_flags(char *label, unsigned int value)
{
    printf("%s\t: %d\t:", label, value);
    binary_print(value);
    printf("\n");
}

void binary_print(unsigned int value)
{
    unsigned int mask;
    unsigned int bit_iterator;

    // Loop through all 32 bits
    for (int byte_iterator = 0; byte_iterator < 32; byte_iterator++) {
        mask = 1 << (31 - byte_iterator); // Create a mask for each bit position
        
        if (value & mask)
            printf("1");
        else
            printf("0");
        
        // Print a space after every 8 bits (1 byte)
        if ((byte_iterator + 1) % 8 == 0) {
            printf(" ");
        }
    }
}
```
The output is:
```sh
bobo@bobo-ws ➜ ./fcntl_flags                       
O_RDONLY                        : 0     :00000000 00000000 00000000 00000000 
O_WRONLY                        : 1     :00000000 00000000 00000000 00000001 
O_RDWR                          : 2     :00000000 00000000 00000000 00000010 

O_APPEND                        : 1024  :00000000 00000000 00000100 00000000 
O_TRUNC                         : 512   :00000000 00000000 00000010 00000000 
O_CREAT                         : 64    :00000000 00000000 00000000 01000000 

O_WRONLY|O_CREAT|O_APPEND       : 1089  :00000000 00000000 00000100 01000001 
```
Using bit flags with bitwise logic gates combination is efficient and commonly used technique. As long as each flag is number that only has unique bits turned on, the effect of doing bitwise OR on these values is the same as adding them. For example 1 + 1024 + 64 = 1089. This technique only works when all the bits are unique.