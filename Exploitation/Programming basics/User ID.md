Every user under Unix like system has unique ID that can be displayed with command `id`:
```sh
bobo@bobo-ws ➜ id  
uid=1000(bobo) gid=1000(bobo) groups=1000(bobo),3(sys),108(vboxusers),981(rfkill),998(wheel)
bobo@bobo-ws ➜ id bobo     
uid=1000(bobo) gid=1000(bobo) groups=1000(bobo),3(sys),998(wheel),981(rfkill),108(vboxusers)  
bobo@bobo-ws ➜ id root  
uid=0(root) gid=0(root) groups=0(root)
```
The `root` user has ID 0. To switch to another user we can use `su` command. To execute command under root we can use command `sudo`.

When we create file for example with this demo: [[File Access#File access Demo]] the created file will have read and write rights only for that user. So if we changed user to different account, we would not have rights to access the file. In this case only the owner can read and write to it.

The `/etc/passwd` file contains login information for multiple accounts. For example when the user wants to change login shell using `chsh` program, it needs to be able to change only part of the file that is relevant to the proper user. This is done using `setuid` permission. This is additional permission bit that can be set using `chmod`. When program with this flag is executed, it runs as the user ID of the file owner:
```
bobo@bobo-ws ➜ ls -l /usr/bin/chsh /etc/passwd  
-rw-r--r-- 1 root root  1975 24. zář 18.17 /etc/passwd  
-rwsr-xr-x 1 root root 22648  4. čec 10.24 /usr/bin/chsh
```
The program `chsh` has its `setuid` flag setup, that can be seen with the `s` in the `ls` output above. Since it has this flag set up and owner of this program is root, whoever runs this program - the program will run as if the user is root. The `/etc/passwd` is also owned by the root and allows only root to write to it. This means running a program has its true owner and an effective owner. These IDs can be show using `getuid()` and `geteuid()` C functions:
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("Real uid: %d\n", getuid());
    printf("Effective uid: %d\n", geteuid());
}
```
```sh
bobo@bobo-ws ➜ ls -l uid_demo
-rwxr-xr-x 1 bobo bobo 15552 25. zář 12.23 uid_demo
bobo@bobo-ws ➜ sudo chown root:root ./uid_demo
[sudo] password for bobo: 
bobo@bobo-ws ➜ ./uid_demo 
Real uid: 1000
Effective uid: 1000
```
The output of this program is the id of current user and effective user. When we use command `chown` to change owner to root, we can still see the output is current user and not root. We need to change permissions so it has `setuid` flag. Since this file is now owned by root we need to use `sudo`:
```sh
bobo@bobo-ws ➜ sudo chmod u+s ./uid_demo
bobo@bobo-ws ➜ ls -l uid_demo
-rwsr-xr-x 1 root root 15552 25. zář 12.23 uid_demo
bobo@bobo-ws ➜ ./uid_demo 
Real uid: 1000
Effective uid: 0
```
Now when we execute, we can see that the effective user is root. This means the program can access files as a root. This is how `chsh` can do its job as root.
# Note taking program demo
We will first separate common functions into header file 'hacking.h':
```c
//hacking.h
//Function that displays error message and exits the program
void fatal(char *message)
{
    char error_message[100];

    strcpy(error_message, "[!] Fatal error ");
    strncat(error_message, message, 83);
    perror(error_message);
    exit(-1);
}

//Error chekced malloc
void *ec_malloc(unsigned int size)
{
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL)
    {
        fatal("in ec_malloc() on memory allocation");
    }
    return ptr;
}
```
Then we [[Include]] it into the main program with `include "hacking.h"` in the main source file:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include "hacking.h"

void usage(char *prog_name, char *filename)
{
    printf("Usage %s <data to add to %s>\n", prog_name, filename);
    exit(0);
}

void fatal(char *); //Handle fatal error
void *ec_malloc(unsigned int); //Error checked malloc;
int main(int argc, char *argv[])
{
    int userid, fd; //file descriptor
    char *buffer, *datafile;

    buffer = (char *) ec_malloc(100);
    datafile = (char *) ec_malloc(20);
    strcpy(datafile, "/var/notes");

    if(argc < 2)
    {
        usage(argv[0], datafile); //When not enough arguments display usage
    }

    strcpy(buffer, argv[1]); //copy into buffer

    printf("[DEBUG] buffer  @%p: \'%s\'\n", buffer, buffer);
    printf("[DEBUG] datafile  @%p: \'%s\'\n", datafile, datafile);

    strncat(buffer, "\n", -1); //Add new line at the end
    //opening file
    fd = open(datafile, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);
    if(fd == -1)
    {
        fatal("in main() while opening file");
    }
    printf("[DEBUG] file descriptor is %d\n", fd);

    userid = getuid();

    //writing data
    if(write(fd, &userid, 4) == -1) //Write the user ID before data
    {
        fatal("in main() while writing userid to file");
    }
    write(fd, "\n", 1); //Terminate line
    if(write(fd, buffer, strlen(buffer)) == -1)
    {
        fatal("in main() while writing buffer to file");
    }
    write(fd, "\n", 1); //Terminate line
    //Closing the file
    if(close(fd) == -1)
    {
        fatal("in main() while closing file");
    }

    printf("Note has been saved.\n");
    free(buffer);
    free(datafile);
}
```
This program is modified [[File Access#File access Demo]]. The location of the note is changed to `var`  instead of temp. Also we now get current user id and prepend it. The file entry is also prepended with user id. Since the `write` function expects pointer to the source of data, we have to use `&` with our user id.
```sh
bobo@bobo-ws ➜ gcc -o  notetaker main.c             
bobo@bobo-ws ➜ sudo chown root:root ./notetaker                    
bobo@bobo-ws ➜ sudo chmod u+s ./notetaker                          
bobo@bobo-ws ➜ ls -l notetaker                                     
-rwsr-xr-x 1 root root 16200 25. zář 13.12 notetaker
bobo@bobo-ws ➜ ./notetaker "this is a test of multi user notetaker"
[DEBUG] buffer  @0x5562b2fcd2a0: 'this is a test of multi user notetaker'
[DEBUG] datafile  @0x5562b2fcd310: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
bobo@bobo-ws ➜ ls -l /var/notes                     
-rw------- 1 root bobo 45 25. zář 13.13 /var/notes
```
In the preceding output the `notetaker` program is changed so it is owned by root and is set with `setuid` permission flag. Now when the program is executed the program runs as root and the created file is owned by root also. The file is in group of the user that ran the program in this case `bobo`.
```sh
bobo@bobo-ws ➜ cat /var/notes
cat: /var/notes: Permission denied
bobo@bobo-ws ➜ sudo cat /var/notes
�
this is a test of multi user notetaker

bobo@bobo-ws ➜ sudo hexdump -C /var/notes
00000000  e8 03 00 00 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|
00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 20 75 73 65  |est of multi use|
00000020  72 20 6e 6f 74 65 74 61  6b 65 72 0a 0a           |r notetaker..|
0000002d
bobo@bobo-ws ➜ pcalc 0x03e8
        1000                    0x3e8                   0y1111101000
```
As we can see the notes file contains  the user ID (1000) of the current user. Because of little endian order, the ID bytes are in reversed order. In order for a normal user to read its notes an complementary program will be needed that will read proper note.
# Note search demo
This program uses the `setuid` flag to access `/var/notes` created in demo above:
```c
#include <asm-generic/errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include "hacking.h"

#define FILENAME "/var/notes"

int print_notes(int, int, char *);//note printing function
int find_user_note(int, int);//Seek in file for a note for user
int search_note(char *, char *);//Search for keyword function
void fatal(char *);

int main(int argc, char *argv[])
{
    int userid, printing=1, fd;     //File descriptor
    char searchstring[100];

    if(argc > 1)
    {
        //If there is more than 1 argument, copy second argument into search string
        strcpy(searchstring, argv[1]);
    }
    else {
        searchstring[0] = 0; //search string is empty
    }

    userid = getuid();
    fd = open(FILENAME, O_RDONLY); //Open file for read only
    if(fd == -1)
        fatal("in main() while opening file for reading");
    while (printing) {
        printing = print_notes(fd, userid, searchstring);
    }
    printf("---------[ end of note data ]---------");
    close(fd); //Always close
}

//function that print notes for given uid and with optional search
int print_notes(int fd, int uid, char *searchstring)
{
    int note_length;
    char byte = 0, note_buffer[100];

    note_length = find_user_note(fd, uid);
    if(note_length == -1)
        return 0;
    
    read(fd, note_buffer, note_length);//read note data
    note_buffer[note_length] = 0; //terminate note data

    if(search_note(note_buffer, searchstring))
        printf(note_buffer);

    return 1;
}

//Function to find the next note for a given userID
//it returns -1 when the end of file is reached
//otherwise it returns the lenght of the found note
int find_user_note(int fd, int user_id)
{
    int note_uid = 1;
    unsigned char byte;
    int lenght;

    while (note_uid != user_id) { //loop until the user with the id found
        if(read(fd, &note_uid, 4) != 4)
            return -1; //If 4 bytes are not read, return end of file code
        if(read(fd, &byte, 1) != 1) //Read the new line separator
            return -1;
        byte = lenght = 0;
        while (byte != '\n') { //figfure out how many lines to the end of new line
            if(read(fd, &byte, 1) != 1) //if byte is not read return end of file code
                return -1;
            lenght++;
        }
    }
    lseek(fd, lenght * -1, SEEK_CUR); //Rewind the file
    printf("[DEBUG] found a %d byte note for user id %d\n", lenght, user_id);
    return lenght;
}

//Function that searches forthe note
int search_note(char *note, char *keyword)
{
    int i, keyword_length, match = 0;

    keyword_length = strlen(keyword);
    if(keyword_length == 0) //If there is no search string return match sucess
        return 1;

    for (i=0; i < strlen(note); i++) { //Iterate over bytes in note
        if(note[i] == keyword[match]) //If byte matches keyword
            match++; //get ready to match next byte
        else {
            if(note[i] == keyword[0])//If byte matches first keyword byte
                match = 1; //start the match with 1
            else
                match = 0; //otherwise set it to zero
        }
        if(match == keyword_length)
            return 1; //return matched
    }
    return 0; //return not matched
}
```
This program accepts optional parameter for search, that can filter contents of the notes stored. It also uses `lseek()` function that tells the program to move the read position forward from current position in the file by `lenght * -1` bytes. Since this is negative number, it will move backwards.
```sh
bobo@bobo-ws ➜ gcc -o notesearch notesearch.c   
bobo@bobo-ws ➜ sudo chown root:root ./notesearch
[sudo] password for bobo: 
bobo@bobo-ws ➜ sudo chmod u+s ./notesearch   
bobo@bobo-ws ➜ ./notesearch 
[DEBUG] found a 39 byte note for user id 1000
this is a test of multi user notetaker
---------[ end of note data ]---------%    
```
When compiled and `setuid` is added as root, the `notesearch` program will work as expected. Its program logic is setup in a way, that prevents other users from reading their notes.
Even though both `notetaker` and `notesearch` programs are `suid` root and have full read and write access to the `/var/notes`, the program will ensure only authors of the notes have access to them. This is very similar to how `passwd` access works. It stores the login information under root user, but every user can change data related to them via the user id.